#!/bin/bash
set -e

board_dim=4
total_tiles=$((board_dim * board_dim))
ENABLE_LOGGING=false

log() {
	if $ENABLE_LOGGING; then
		echo "# $@"
	fi
}

trace() {
	local name=$1
	shift
	local stage=$1
	shift
	log TRACE :: $name :: $stage $@
}

TODO() {
	log TODO: $@
	exit 1
}

game_loop() {
	while $game_in_progress; do
		render_board
		wait_for_input
		process_input
		if $input_was_valid; then
			add_new_square
			input_was_valid=false
		fi
		check_for_game_over
	done
}

new_game() {
	trace new_game ENTER
	score=0
	clear_field_of_play
	add_new_square
	add_new_square
	game_in_progress=true
	game_loop
	trace new_game EXIT
}

clear_field_of_play() {
	trace clear_field_of_play ENTER
	for ((i=0; i<$total_tiles; ++i)); do
		board[$i]=0
	done
	trace clear_field_of_play EXIT
}

add_new_square() {
	trace add_new_square ENTER
	local need_to_add=true
	local new_val=$((RANDOM % 10))
	if [[ $new_val == 0 ]]; then
		new_val=2
	else
		new_val=1
	fi
	while $need_to_add; do
		log "add_new loop..." ;
		local cell_index=$((RANDOM % total_tiles))
		local current_content=${board[$cell_index]}
		log "current content=$current_content"
		if [[ $current_content == 0 ]]; then
			log "adding square at ($x,$y)"
			local need_to_add=false
			board[$cell_index]=$new_val
		fi
	done
	trace add_new_square EXIT
}

check_for_game_over() {
	# TODO game over check is a bit more complex than "no new squares"
	return
	for ((i=0; i<$total_tiles; ++i)); do
		if [[ ${board[$i]} == 0 ]]; then
			return
		fi
	done
	echo "There are no empty squares."
	echo "Game over."
	exit 1
}

wait_for_input() {
	read -s -n 1 in_key
}

get_index() {
	local x=$1
	local y=$2
	echo $((y * board_dim + x))
}

get_content() {
	local x=$1
	local y=$2
	local index=$(get_index $x $y)
	echo ${board[$index]}
}

set_content() {
	local x=$1
	local y=$2
	local new_value=$3
	local index=$(get_index $x $y)
	board[$index]=${new_value}
}

shuffle() {
	case $1 in
		up )
			for ((x=0; x<$board_dim; ++x)); do
				for ((y=0; y<$board_dim; ++y)); do
					for ((repeats=$((board_dim-y)); repeats>0; --repeats)); do
						local current_content=$(get_content $x $y)
						if [[ $current_content == 0 ]]; then
							# move everything in this column up one
							for ((z=$y; z<$((board_dim-1)); ++z)); do
								local one_above=$(get_index $x $((z+1)))
								local value_above=${board[$one_above]}
								if [[ $value_above > 0 ]]; then
									board[$(get_index $x $z)]=${value_above}
									board[$one_above]=0
									input_was_valid=true
								fi
							done
						fi
					done
				done
			done
			;;
		left )
			for ((y=0; y<$board_dim; ++y)); do
				for ((x=0; x<$board_dim; ++x)); do
					for ((repeats=$((board_dim-x)); repeats>0; --repeats)); do
						local current_content=$(get_content $x $y)
						if [[ $current_content == 0 ]]; then
							# move everything in this row left one
							for ((z=$x; z<$((board_dim-1)); ++z)); do
								local one_above=$(get_index $((z+1)) $y)
								local value_above=${board[$one_above]}
								if [[ $value_above > 0 ]]; then
									board[$(get_index $z $y)]=$value_above
									board[$one_above]=0
									input_was_valid=true
								fi
							done
						fi
					done
				done
			done
			;;
		down )
			for ((x=$((board_dim-1)); x>=0; --x)); do
				for ((y=$((board_dim-1)); y>0; --y)); do
					for ((repeats=$y; repeats>0; --repeats)); do
						local current_content=$(get_content $x $y)
						if [[ $current_content == 0 ]]; then
							# move everything in this column above this square down one
							for ((z=$y; z>0; --z)); do
								local one_above=$(get_index $x $((z-1)))
								local value_above=${board[$one_above]}
								if [[ $value_above > 0 ]]; then
									board[$(get_index $x $z)]=$value_above
									board[$one_above]=0
									input_was_valid=true
								fi
							done
						fi
					done
				done
			done
			;;
		right )
			for ((y=$((board_dim-1)); y>=0; --y)); do
				for ((x=$((board_dim-1)); x>0; --x)); do
					for ((repeats=$x; repeats>0; --repeats)); do
						local current_content=$(get_content $x $y)
						if [[ $current_content == 0 ]]; then
							# move everything in this row left one
							for ((z=$x; z>0; --z)); do
								local one_above=$(get_index $((z-1)) $y)
								local value_above=${board[$one_above]}
								if [[ $value_above > 0 ]]; then
									board[$(get_index $z $y)]=$value_above
									board[$one_above]=0
									input_was_valid=true
								fi
							done
						fi
					done
				done
			done
			;;
	esac
}

squash() {
	trace squash ENTRY :: $@
	case $1 in
		up ) squash_up_or_left 0 1 ;;
		left ) squash_up_or_left 1 0 ;;
		down ) squash_down_or_right 0 1 ;;
		right ) squash_down_or_right 1 0 ;;
	esac
}

squash_down_or_right() {
	local x_change=$1
	local y_change=$2
	for ((x=$((board_dim-1)); x>=$x_change; --x)); do
		for ((y=$((board_dim-1)); y>=$y_change; --y)); do
			local this_content=$(get_content $x $y)
			local next_index=$(get_index $((x-x_change)) $((y-y_change)))
			local next_content=${board[next_index]}
			log "squashing ($x,$y)->$next_index.  this=$this_content; next=$next_content"
			if [[ $((next_index > -1)) == 1 ]]; then
				if [[ $this_content > 0 ]] && [[ $this_content == $next_content ]]; then
					local new_value=$((this_content * 2))
					set_content $x $y $new_value
					((score += new_value))
					board[$next_index]=0
					input_was_valid=true
					log "Done squashing."
				else
					log "Actually not squashing."
				fi
			fi
		done
	done
}

squash_up_or_left() {
	local x_change=$1
	local y_change=$2
	for ((x=0; x<$((board_dim-x_change)); ++x)); do
		for ((y=0; y<$((board_dim-y_change)); ++y)); do
			local this_content=$(get_content $x $y)
			local next_index=$(get_index $((x+x_change)) $((y+y_change)))
			local next_content=${board[next_index]}
			log "squashing.  this=$this_content; next=$next_content"
			if [[ $this_content > 0 ]] && [[ $this_content == $next_content ]]; then
				local new_value=$((this_content * 2))
				set_content $x $y $new_value
				((score += new_value))
				board[$next_index]=0
				input_was_valid=true
				log "Done squashing."
			else
				log "Actually not squashing."
			fi
		done
	done
}

move() {
	local direction=$1
	shuffle $direction
	squash $direction
	shuffle $direction
}

process_input() {
	input_was_valid=false
	case $in_key in
		w ) move up ;;
		a ) move left ;;
		s ) move down ;;
		d ) move right ;;
		* ) wait_for_input; process_input ;;
	esac
}

HORIZONTAL_LINE='#################################'
PADDING_LINE='#'
for ((i=0; i<$board_dim; ++i)); do
	PADDING_LINE="${PADDING_LINE}       #"
done
render_board() {
	trace render_board ENTER
	clear

	local counter=$board_dim
	local disp="SCORE: $(printf '%7s' $score)\n\n$HORIZONTAL_LINE\n$PADDING_LINE\n"
	for ((i=0; i<$total_tiles; ++i)); do
		local cell_content=${board[$i]}
		if [[ $cell_content == 0 ]]; then
			local cell_content='     '
		else
			local cell_content=$(printf '%5s' $cell_content)
		fi
		local disp="${disp}# ${cell_content} "
		if ((--counter == 0)); then
			local disp="${disp}#\n$PADDING_LINE\n$HORIZONTAL_LINE"
			# only add trailing padding line if there is more board to render
			if ((i+1 < total_tiles)); then
				local disp="${disp}\n$PADDING_LINE\n"
				local counter=$board_dim
			fi
		fi
	done
	echo -e "${disp}"
	trace render_board EXIT
}

new_game

